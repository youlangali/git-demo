<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    //  正则表达式创建的两种方法
    // var reg = new RegExp('abc','m');//构造函数
    // var reg = /abc/;//字面量方法


        // var reg = /acd/i;//ignoreCase缩写,无视大小写
    //     var reg = /acd/g;//global缩写,查找所有匹配字符串，而非查找到第一个就停止

    //  var reg = /acd/;//多行匹配
    // var str = 'AcdAbcdcd\nacd'

        //   \n  换行 
        //   \t   一个制表符缩进
        //  \r   行结束符

        // var str = 'ackg\tjoa';

        // var reg = /^a/gm;//^a   意思是行首第一个a    // gm  全局匹配多行执行
        // var str = 'acavavav\na';

    //使用RegExp的两种方式
    // str.match(reg)
    // reg.test(str)


        // []里面代表一个字符
        // var reg = /[cv]a/g;// [cv]代表第一个字符中cv中是其中一个就满足要求
        // var str = 'acavavava';
        
        //   [0-9]匹配包括0到9的字符，[A-z]// 匹配包括A-Z，a-z的52个字符串
        // var reg = /[0-9]d[a-z]/g;
        // var str = '1230dz'

        // var reg = /[ab][cd][d]/g;
        // var str = 'abcd';
        

        // var reg = /[0-9A-z][cd][d]/g;
        // var str = 'abcd';

        //  ^ 用法
        // var reg = /^[^a][^b]/gm;// 在[]中 ^ 表示非
        // var str = "dc1c\nbc";

        // var reg = /[^a][^b]/g;
        // var str = "ab1cd";

        // var reg = /(anc|acd)[0-9]/g;
        // var str = "acd1";

        //  world
        // \w  === [0-9A-z]
        //  \W  === [^\w]
        
        // var reg = /\wcd2/g;
        // var reg = /\Wcd/g;
        // var str = "b*cd2";

        // \d  === [0-9]
        // \D    ==== [^\d]
        // var reg = /\d\d\d/g;
        // var str = "123";

        // var reg = /\w\d/g;
        // var str = "sa4ofn";// ?
        // var str = "*aa4ofn";

        //   \b   ===  boundary单词边界(单词与单词不连接在一起的就是单词边界)
        //    \B  === 非单词边界
        // var reg = /\bcde\b/g;
        // var str = "abc cde acde";

        // var reg = /\bc/g;
        // var str = "abb cde\ncde*c";

        // var reg = /\bcde\B/g;
        // var str = "abc cdefgh"

        //  \t // table 一个制表符缩进
        // var reg = /\tc/g;
        // // var str = "ac   cde";
        // var str = "ac\tcde";

        //  匹配所有字符，[\d\D]、[\w\W] ……
        // var reg = /[\d\D]/g;
        // var str = "忘记是否恶化";

        //   .   === [^\r\n]
        //   ???
        // var reg = /^\d\d/g;  //  ^在[]之外是以什么为开头
        // // // var reg = /[^\d]\w/g;
        // var str = "a1s1";

        // var reg = /./g;
        // var str = "老 邓身体好";

        // var reg = /[ack][b]/g;
        // // var reg = /[ack]/g;
        // var str = "ackb";
        // var reg = /[0-9]/g;
        // var str  = "165a486";

        //   \s   === 寻找空白字符
        //   \S  === 寻找非空白字符
        // 空白字符可以是：
        //     空格符(space character)
        //     制表符(tab character)
        //     回车符(carriage return character)
        //     换行符(new line character)
        //     垂直换行符(vertical tab character)
        //     换页符(form feed character)

        // var reg = /\s/g;
        // var reg = /\S/g;
        // var str = "afe 12\rf\ne"


        // n+   {1, }   重复1到正无穷
        // n*   {0, }    重复0到正无穷
        // n?   {0,1}    重复{0,1}
        // n{x}  {x}      重复x次
        // n{x,y}  {x,y}     重复x到y 
        //  n{x, }  {x, }     重复x到无穷次

        // var reg = /^abc$/g;
        // var str = "abc";

        // var reg = /^\d|\d$/g;
        // var str = "123abc1";
        
        //   题目： 检查一个字符串首尾是否含有数字？
        // var reg = /^\d|\d$/g;   //   这样是输出一位数字
        // var reg = /^\d[\s\S]*\d$/g;   // 这是输出字符串首尾都有数字
        // var reg = /^\d[\s\S]*|[\s\S]*\d$/g;   // 这是输出自负春首尾一个有数字就行
        // var str = "12ab1";
        
        // var reg = /^a/gm;
        // // var str = "abcde\na"
        // var str = "abcdea"




        //    正则表达式是贪婪表达式，，能匹配多个，绝不输出一个
        // var reg = /\w+/g;
        // var reg = /\w{2,}/g;
        // var reg = /a{1,3}/g;
        // var str = "aaaaaaa";


        // var reg = /[abcdede]/gm;  //  一个占位里面abcdede任选一个都可以匹配
        // var reg = /[^abcdede]/gm;  //  一个占位里面只能匹配除abcdede之外的字符
        // var reg = /ed$/g;
        // var str = "abcdeded";


        // var reg = /^abc$/g;
        // var str = "abcabc";

        // var reg = /^\d|\d$/g;
        // var str = "123abc";


        // // var reg = /ab/g;
        // var reg = /ab/;// 如果没有属性g的情况
        
        // var str = "abababab";
        // console.log(reg.lastIndex)
        // console.log(reg.exec(str))
        // console.log(reg.lastIndex)
        // console.log(reg.exec(str))
        // console.log(reg.lastIndex)
        // console.log(reg.exec(str))
        // console.log(reg.lastIndex)
        // console.log(reg.exec(str))
        // console.log(reg.exec(str))
        // console.log(reg.exec(str))
        //     // 配合使用
        // reg.lastIndex = 2; //手动更改会使得reg.exec展示相应的index位置的字符串
        // console.log(reg.exec(str))//   返回str.match(reg)的值中匹配的第二个


        //     子表达式（a）    \1反向引用第一个子表达式 \2反向引用第二个子表达式

        //  选出任何的xxyy形式的正则表达式
        // var str = "aabb1122aaaabb";
        // var reg = /(\w)\1(\w)\2/g;
        // console.log(reg.exec(str))
        // console.log(str.match(reg))



        // var reg = /(\w)\1(\w)\2/g;
        // var reg = /d/g;
        // var str = "aabbccddd";
        // console.log(str.split("c"));// split  将字符串分割成字符串数组
        // // console.log(str.split(reg));
        
        //   reg,reg1并不能相互改变
        // var reg = /abce/m;
        // var str = "acc";
        // var reg1 = new RegExp(reg);


        // 正向预查，正向断言(非偷懒原则:能匹配多个就绝不匹配一个)
        //    n? 非偷懒原则
        // var str = "abaaaa";
        // var reg = /a{1,3}/g;//偷懒原则
        // var reg = /a{1,3}/g;
        // var reg = /a+?/g;// 非偷懒原则
        // var reg = /a?/g;//非偷懒原则
        // var reg = /a(?=\w)/g;
        
        // var str = "aaaaaaaaabbbbbbbbbbccccccc";
        // var reg = /(\w\1*)/g;
        // console.log(str.replace(reg,"$1"))


        // var str = "1000000000";
        // var reg = /(?=(\B)(\d{3})+$)/g;
        // console.log(str.replace(reg,"."))

        //$以什么为结尾，\w{n}代表\w重复n次，匹配多个字符串，再看量词+将匹配的子表达式重复（将内容链接一起）
        // var str = "abbabbbb";
        // var reg = /a(?=(b{1,2})+$)/g;
        
        
        //   主题   string.split方法,每个字符串之间都有空串

        // var str = "acnbcccjorc";
        // var str = "ccbccbccdc";
        // var str = "cccccbbcccb"
        // var str  = "cccccccbbccccfcc cccccc";
        // // str.split('cc');
        // // str.split('c');


        // var str = "abc";
        // var reg = /(\w)\1(\w)\2/g;
        // console.log(str.split(reg));

        //  replace
        // var str = "aabb";
        // // var reg = /a$/g;
        // var reg = /(\w)\1(\w)\2/g;
        // console.log(str.replace(reg,"b"));
        // console.log(str.replace(reg,"$2$2$1$1"));//$是指正则表达式匹配全局也就是最终的结果，$2是指第二个子表达式,，$1是指第一个子表达式
        // console.log(str.replace(reg,function($,$1,$2){//可以加函数，系统会自动执行
        //     // return $2 + $2 + $1+ $1
        //     return $2 + $2 + $1+ $1 + "acb"
        //     // return $
        // }))


            //string方法  toUperCase 变大写   toLowerCase  变小写
            // var str = "aFb";
            // console.log(str.toUpperCase())
            // console.log(str.toUpperCase().toLowerCase())



            //  题目：   the-first-name变为theFirstName
            // var str = "the-first-name";
            // var reg = /-(\w)/g;//用（）括起来就是子表达式
            // console.log(str.replace(reg,function($,$1,$2){
            //   return  $1.toUpperCase();
            // }))

            // var str = "aaaaaaaaaabbbbbbbcccccc";
            // var reg = /(\w)\1*/g;
            // console.log(str.replace(reg,"$1"))


                //   reg.source,  reg.global    reg.ignoreCase    reg.multiline
                // var str = "aabb"
                // var reg = /a/g;;
                // reg.source//返回reg内容
                // reg.global  //true or false
                // reg.multiline  //  true or false
                // reg.ignoreCase //ture of false


                // var str = "aaaaaa";
                // var reg = /a{1,3}?/g;//  非偷懒原则
                // var reg = / ?/g;//


                //   
    </script>
</body>
</html>