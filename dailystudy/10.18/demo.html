<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div name= "ab" id="ali" class="ali" style="">
        <!-- this is comment -->
        <span>
            <strong class="strong" id= "ceshi">

            </strong>
        </span>
        <i></i>
        <form action="">
                123
        </form>
        <p>

        </p>
        <div>

        </div>
    </div>
    <script>
        // 通过 name来取div
        // var div = document.getElementsByName('ab')[0];
        // var id = document.getElementById('ali');
        // var strong  = document.querySelector('div span strong')//  仿css写法
        // var strong  = document.querySelectorAll('div span strong')


        //在文本中创建div
        // var newDiv = document.createElement('div');//在js中创建div
        // document.body.appendChild(newDiv);//   将div放入文档中

        //  遍历节点树，所有的浏览器都能很好的兼容,最顶端节点就是#document
        //   parentNode,childNodes,nextSibling,previousSibling,firstChild,lastChild

        // var strong = document.getElementsByTagName('strong')[0];
        // var form = document.getElementsByTagName('form')[0];
        // var div = document.getElementsByClassName('ali')[0];
        

        //   遍历元素节点，只有child是ie兼容的,child用的最多，最顶端的元素节点是html
        //    parentElement,children,firsElementChild,lastElementChild,
        //   nextElementSibling,previousElementSibling,node.childElementCount  === node.children.length
        

        //    节点的四个属性
        //    nodeName   节点名称      nodeValue    节点文本内容（只有text节点和commen节点有）
        //    nodeType     节点类型，    返回值是相应的数字1,2,3,8，9,11
        //      attributes     节点的属性，
        //     node.hasChildNodes(),判断是否有子节点（注：不是元素节点，而是节点，只要内容中间有空隙就有text节点）
          
          



          //     返回元素子节点    不用children
        //   var div = document.getElementById("ali");
        //   var len = div.childNodes.length;
        //   var arr = [];
        //   for(var i = 0; i < len;i ++){
        //       if(len[i].nodeType == 1){
        //           arr.push(len[i])
        //       }
        //   }
          
// function retElementChild(node){
//     // no  children
//     var temp = {
//             length: 0,
//             push: Array.prototype.push,
//             splice: Array.prototype.splice,
//         },
//         child = node.childNodes,
//         len = child.length;
//         for(var i = 0;i < len;i ++){
//             if(child[i].nodeType == 1){
//                 temp.push(child[i]);
//             }
//         }
//         return temp;
// }

        


    //   给字符串去重

    // var a = "qtuheitwwtopeowtuqiou";
    // function firCode(letter){
    //     var 
    // }


//     1、遍历元素节点树（在原型链上编程）
        // Element.prototype.retElement = function(){
        //     if(ele.nodeType == 1){
        //         var ele = this.children;
        //         return child;
        //     }
            
        // }




            //    2、封装函数，返回元素e的第n层祖先元素节点
        //     function retParent(e,n){
        //             var par = e.parentElement;
        //         if(n > 1){
        //         for(var i = 1;i < n; i ++){
        //             par = par.parentElement
        //         }
        //         }
        //         return par
        //     }
        //    var parent = retParent(strong,3);

            //     老师方法//   完美的利用了0为介点，0 的Boolean值为false，
            // function retParent(elem,n){
            //     while(elem && n){//保证elem有意义
            //         elem = elem.parentElement;
            //         n--;
            //     }
            //     return elem;
            // }




        //  3、封装函数，返回元素e的第n个元素节点，n为正，返回后面的兄弟元素节点，n为负，返回
        //     返回前面的兄弟节点，n为0，返回自己
            // function retSibling(e,n){

            //     if(e.nodeType == 1){
            //         var next = e.nextElementSibling,
            //             pre = e.previousElementSibling;
            //         if(n == 0){
            //             return e;
            //         }else if(n > 0){
            //             for(var i = 1 ;i < n;i ++){
            //                 next = next.nextElementSibling;
            //             }
            //             return next;
            //         }else if(n < 0){
            //             for(var  i = 1;i < -n;i ++){
            //                 pre = pre.previousElementSibling;
            //             }
            //             return pre;
            //         }
            //     }
            // }

            //      老师方法
            


                //   编辑函数，封装myChildren功能，解决以前部分浏览器的兼容性问题

                // function myChildren(e,n){
                //     var child = e.children;
                //     var len = child.length;
                //     if(n == "last"){
                //         return child[length-1];
                //     }else if(n == "first"){
                //         return child[0];
                //     }else{
                //         return child[n-1];
                //     }

                // }
                // var a = myChildren(div,4);



                //     题目理解错，模拟children方法
                // Element.prototype.myChildren = function(){
                //     var child = this.childNodes;
                //     var len = child.length;
                //     var arr = [];
                //     for(var i = 0;i < len;i ++){
                //         if(child[i].nodeType == 1){
                //             arr.push(child[i]);
                //         }
                //     }
                //     return arr;
                // }


                    //    自己封装hasChildren()方法，不可用children属性，
                    // function hasChildren(e){
                    //     var childnode = e.childNodes,
                    //     len = childnode.length;
                    //     for(var i = 0;i < len;i ++){
                    //         if(childnode[i].nodeType == 1){
                    //             return true;
                    //         }else{
                    //             return false;
                    //         }
                    //     }
                    // }

                        //  老师方法  假设nextElementSibiling因为兼容不好使
                        //    for 循环的灵活用法,考虑容错情况
                        // var form = document.getElementsByTagName('form')[0];


                        // function retSibling(e,n) {
                        //         while (e && n) {
                        //             if (n > 0) {
                        //                 if (e.nextElementSibling) {
                        //                     e = e.nextElementSibling;
                        //                 } else {
                        //                     for (e = e.nextSibling; e && e.nodeType != 1; e = e.nextSibling);
                        //                 }
                        //                 n--;
                        //             } else 
                        //             {
                        //                 if (e.previousElementSibling) {
                        //                     e = e.previousElementSibling;
                        //                 } else {
                        //                     for (e = e.previousSibling; e && e.nodeType != 1; e = e.previousSibling);
                        //                 }
                        //             n++;
                        //             }
                        //         }
                        //         return e;
                        //     }






                            //  dom 结构树
                    // var div = document.getElementById("ali");
                    //   HTMLElement.prototype.ab = "abc";
                        // HTMLElement.prototype.a = "ali";
                        // HTMLBodyElement.prototype.ab = "abc";
                        // var body = document.getElementsByTagName('body')[0];
                        // var head = doscument.getElementsByTagName('head')[0];

                        
                        



    </script>
    <script>
       // getElementById方法定义在Document.prototype上，Element节点上不能用
        // var div = document.getElementById('ali');
        // var strong = div.getElementById('ceshi');//   会报错

        //   document.body --> body
        //    document.head    -->   head
        //     document.documentElement   -->   html
        

        
    </script>
</body>
</html>