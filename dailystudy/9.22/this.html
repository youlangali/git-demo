<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    // this的使用


                // function test(c){
                //     //  var this = Object.create(test.prototype)

                //     var a = 213;
                //     function b(){};

                // }
                // // AO{
                // //     arguments : [1],
                // //     this : window,
                // //     c : 1,
                // //     a : undefined,
                // //     b : function(){}
                // // }

                // test(1);
                // new test;


//    只要不是被调用，类似于  b.fun();那么函数就是要走预编译环节，那么this就是指向window



                    // var name = "222";
                    // var a = {
                    //     name : "111",
                    //     say: function(){
                    //         console.log(this.name);
                    //     }
                    // }
                    // var fun = a.say;
                    // fun();  //"222"
                    // a.say();   //"111"
                    // var b = {
                    //     name : "333",
                    //     say :function (fun){
                    //         // var this ---> b
                    //         fun();//但是函数在这儿执行，但是this被调用的那个函数并未被谁调用，所以走的是预编译的环节，故this指向window；
                    //     }
                    // }
                    // b.say(a.say);//  "222"
                    // b.say = a.say;
                    // b.say();//  "333"








                    // var bar = {a :"002"}
                    // function print(){
                    //     bar.a = "a";
                    //     Object.prototype.b = "b";
                    //     return function inner(){
                    //         console.log(bar.a);
                    //         console.log(bar.b);

                    //     }
                    // }
                    // print()();

    
                        //  test1
    
                    // var foo = 123;
                    // function print(){
                    //     this.foo = 234;
                    //     console.log(foo);// 123
                    // }
                    // new print();



                        //   test 2

                        // var foo = 123;
                        // function print(){
                        //     this.foo = 234;
                        //     console.log(foo);//  234
                        // }
                        // print();

    



                //  test 3
                // var foo = "123";
                // function print(){
                //     var foo = "456";
                //     this.foo = "789";
                //     console.log(foo);// "456"
                // }
                // print();



                    //   全局环境的GO对象就是window对象
                    //  test 4    运行test()和new test()的结果分别是什么
                    // var a = 5;
                    // function test(){
                    //     // var this = Object.create(test.prototype)
                    //     a = 0;
                    //     alert(a);//0             // 0
                    //     alert(this.a);//  5       // undefined
                    //     var  a;
                    //     alert(a);// 0             //  0
                    // }
                    // // test();
                    // // new test()







                        // function print(){
                        //     var marty = {
                        //         name: "marty",
                        //         printName:function(){
                        //             console.log(this.name);
                        //         }
                        //     }
                        //     var test1 = {name:"test1"};
                        //     var test2 = {name:"test2"};
                        //     var test3 = {name: "test3"};
                        //     test3.printName = marty.printName;
                        //     var printName2 = marty.printName.bind({name: 123});
                        //     marty.printName.call(test1);// test1
                        //     marty.printName.apply(test2);// test2
                        //     printName2();
                        //     test3.printName();//test3
                        // }
                        // print();





                    //  var bar = {a: "002"};
                    //  function print(){
                    //      bar.a = "a";
                    //      Object.prototype.b = "b";
                    //      return function inner(){
                    //          console.log(bar.a);// "a"
                    //          console.log(bar.b);//  "b"
                    //      }
                    //  }
                    //  print()();


                        // var arr = [1,2,3];
                        // var arr1 = [];
                        // for(var i = 0;i < 3;i++){
                            
                        //     arr1.push(arr[i]);
                        // }



       //  疑惑： 为什么当Target[prop] = Origin[prop];可以将属性都赋值过去了
                    //    var obj = {
                    //        name: "123",
                    //        age: 123,
                    //        sex: "female",
                    //        card: ["visa" , "unionpay" , [1,2]],
                    //     //    __proto__:test.prototype
                    //    } 
                    //    var obj1 = {};


                    //    function clone(Target,Origin){
                    //        for(var prop in Origin){//取出Origin属性
                    //            if(Origin.hasOwnProperty(prop)){  //  只要属于Origin本身的属性，继承的不要

                    //            if(typeof(Origin[prop]) === "object"){ // 区别原始值与引用值
                    //                 // Origin[prop] = 1;
                    //                 // Origin[prop].push(4);
                    //                 if(Origin[prop] instanceof Array){ //区分数组和对象
                    //                     var arrlen = Origin[prop].length;
                    //                     console.log(arrlen)
                    //                     for(var i = 0;i<arrlen;i++){  //对象
                                            
                    //                         //   if(prop[i] instanceof Array){

                    //                         //   }  else{  
                    //                         //       Target[prop][i]= prop[i];
                    //                         //   }
                    //                         // console.log(Origin[prop][i])
                    //                         // Target[prop]= Origin[prop][i];
                    //                         // var mid = {};
                                                
                                           
                    //                     //    console.log(a)
                    //                         Target[prop] = Origin[prop][i]
                    //                         // console.log(Target[prop])
                    //                         // a[i]= prop[i];
                                        
                    //                     }
                    //                 }
                    //                 else{

                    //                 }
                    //            }else{
                    //             Target[prop] = Origin[prop];

                    //            }
                    //            }
                    //        }
                    //    }
                    //    clone(obj1,obj)
                    //    obj1.card.push(3);


                        //    听课后的test
                    //    var obj = {
                    //        name: "123",
                    //        age: 123,
                    //        sex: "female",
                    //        card: ["visa" , "unionpay" , [1,2]],
                    //     //    __proto__:test.prototype
                    //    } 
                    //    var obj1 = {};
                    //    function deepClone(origin,target){
                    //     var target = target || {},
                    //         arrStr = Object.prototype.toString,
                    //         arr = "[object Array]";
                    //        for(var prop in origin){
                    //            if(origin.hasOwnProperty(prop)){ // 判断是否是对象本身的属性
                    //                if(origin[prop] !== "null" && typeof(origin[prop]) == "object"){// 判断是都是引用值
                    //                     if(arrStr.call(origin[prop]) == arr){//是数组
                    //                         target[prop] = [];
                    //                     }else{//是对象执行
                    //                         target[prop] = {};
                    //                     }
                    //                     deepClone(origin[prop],target[prop])
                    //                }else{
                    //                    target[prop] = origin[prop];
                    //                }
                    //            }
                    //        }
                    //        return target;
                    //    }
                    //    deepClone(obj,obj1);
                        // 遍历对象
                        //  1 判断是否是引用值
                        //  2 判断是对象还是数组


                       //   老师的正确答案    函数只会运行一次，所以不会将函数运行后的
                       //    对obj进行的更改进行到obj1中    函数的封装
                       
                        // function deepClone(origin,target){
                        //     var target = target || {},
                        //     toStr = Object.prototype.toString,
                        //     arrStr = "[object Array]";
                        //     for(var prop in origin){
                        //         if(origin[prop] !== "null" && typeof(origin[prop]) == "object"){
                        //             // if(toStr.call(origin[prop]) == arrStr){
                        //             //     target[prop] = [];
                        //             // }else{
                        //             //     target[prop] = {};
                        //             // }
                        //             target[prop] = toStr.call(origin[prop]) == arrStr ? [] : {};
                        //             deepClone(origin[prop],target[prop]);
                        //         }else{
                        //             target[prop] = origin[prop]
                        //         }
                        //     }
                        //     return target;
                        // }
                        // deepClone(obj,obj1)
                        // console.log(obj);
                        // console.log(obj1);
                        // obj.card.push(4);
                        // // deepClone(obj,obj1);
                        // console.log(obj);
                        // console.log(obj1);






                    // function test(){
                    //     this.age = 1;
                    //     this.say = "hello"
                    // }
                    // var obj = {
                    //     name: "ali"
                    // }
                    // test.call(obj)

                    // var obj = {
                    //     name: "ali",
                    //     age: 123,
                    // }
                    // for(var key in obj){
                    //     console.log(obj[key])//key 是属性名
                    // }





                    //   arguments 的属性
                    // arguments.callee   调出其所在的函数

                    // var num = (function(n){
                    //     if(n == 1){
                    //         return 1;
                    //     }
                    //     return n * arguments.callee(n - 1)
                    // }(100))


                        //   caller  函数被调用的环境

                        // function test(b){
                        //     demo(2);
                        // }
                        // function demo(a){
                        //     console.log(demo.caller);
                        //     console.log(arguments.callee);
                        // }
                        // test(1)

                    // function test(a,b){
                    //     function ceshi(b){

                    //     console.log(arguments.callee)
                    //     }
                    //     ceshi(1)
                    // }
                    // test (1,2)




        //          条件判断

            //      条件判断  ?  是 : 否
            // 3 > 2 ? console.log(1) : console.log(2);
                // var num = 1 > 0 ? ("10" > "9" ? 1 : 0) : 2;
                //   当两头都是字符串，要根据阿斯克码来看，先看第一位"10" > "9"





                        //    数组
                        // var arr = [];// 字面量方法
                        // var arr = new Array(10);// 10表示字符长度
                        // var arr = new Array(10,1,3,4);//  数字表示数组的内容

                        // var arr = new Array(10,2,3,4);
                        // var arr2 = new Array(10.2);//  报错

                        // var arr1 = [10];
                        // arr[10] = "abc";
                        // console.log(arr);



                        //对空数组进行添加内容
                        // var arr = [1,2,3,4,5,6,7];
                        //     var arr1 = [];
                        // for(var i = 0;i< arr.length;i++){
                        //     arr1[i] = arr[i];
                        // }


                            //     数组常用的方法，改变原数组    
                            //    push 方法
                            // var arr = [];
                            // arr.push(1,2,3,4);
                             
                            //  push方法的原理
                        //     var arr = [1,2,3];
                        //     Array.prototype.push = function(){//在数组的最后加入数字
                        //     for(var i = 0;i < arguments.length;i ++){
                        //         //for循环中间是;
                        //         this[this.length] = arguments[i];// 不用传参，只需要用到
                        //          // 实参，并且该方法被调用的用this来代替
                        //     }
                        // return this.length;
                        //     }
                            

                            //   数组的pop方法
                            //  将数组的最后一位去除，

                            // var arr = [1,2,3,4,5];
                        //    //arr.pop的使用方法
                        //     // arr.pop();// [1,2,3,4]
                        //     // arr.pop(2);// [1,2,3,4]



                            // 模拟pop方法，用不来
                            // Array.prototype.pop = function(){//在数组的最后去除数字
                            //         var arr1 = [];
                            //     for(var i = 0;i < num;i ++){
                            //        arr1[i] = this[i];//for循环中放循环体
                            //        this[i] = arr1[i];
                            //         var num = this.length - 1;

                            //     }
                                
                            //     // this  = [];
                            //         // return this;
                            // }








                            // 模拟pop方法，

                            // Array.prototype.pop = function(){//在数组的最后去除数字
                            //         var arr1 = [];
                            //         this.length --;
                            // }
                            


                                //   数组的unshift方法
                                //  在数组的最前方加入一个，可以传参

                                // var arr = [1,2,3,4];
                                // arr.unshift(1,2,3);//  arr = [1,2,3,1,2,3,4]



                                //  数组的reverse 方法
                                //  将数组倒过来排
                                // var arr = [1,3,5,6];
                                // arr.reverse();//  arr = [6,5,3,1]




                                //   数组的splice方法
                                // 第几位开始，截取多少的长度，在切口处添加新的数组
                                
                                // var arr = [1,2,45,6];
                                // arr.splice(1,2,3,4,5)// 从第一位开始，截取2位长度，然后从切口处放置3,4,5
                                // arr.splice(3,0,5)//   [1, 2, 45, 4, 6]
                                // arr.splice(-1,1)// [1,2,45]


                                // 模拟splice方法中的倒数第一位为-1；
                                // splice = function(pos){
                                //     pos += pos > 0 ? 0 :this.length;
                                // }
                                // -1 = -1 + 4




                                    // 数组的sort方法
                                // 是按照阿斯克码来排列的
                                    
                                    //  1、必须写两个参数
                                    //  2、看返回值  1） 当返回值为负值时，那么前面的数放在前面
                                            //       2） 为正数时，那么后面的数在前
                                        //           3) 为0，不动


                                // var arr = [1,4,7,9,10];
                                // arr.sort(function(a,b){
                                //     // return a - b;// 升序
                                //     // return b - a // 降序
                                // })




                                    //      题目：给一个有序的数组，乱序
                                
                                // var arr = [1,2,3,4,5,6,7];
                                // arr.sort(
                                //     function(a,b){
                                //         return (Math.random() - 0.5)
                                //     }
                                // )


                                  //   题目2 

                                //   var zhou = {
                                //       age: 20,
                                //       name: "zhou",
                                //       sex: undefined
                                //   }  
                                //   var zhang = {
                                //       age:  21,
                                //       name: "zhang",
                                //       sex: "female"
                                //   }
                                //   var wang = {
                                //       age: 22,
                                //       name: "wang",
                                //       sex: "male"
                                //   }
                                //   var arr = [zhou,zhang,wang];
                                //   arr.sort(function(a,b){
                                //       return a.age - b.age;//年龄按照升序排列
                                //   })
                                  
                                  
                                  //   按照阿斯克码值，由少到多进行排列

                                //   var arr = ["ajwgoie","fajwoe4jfawoe","等等我","wo等"];
                                //   function changCode(str){
                                //       var  num = str.length;
                                //       for(var i = 0;i < str.length;i++){
                                //         if(str.charCodeAt(i) > 255){
                                //             num ++;
                                //       }
                                //       }
                                //        return num;
                                //   }
                                // //   changCode("deng");

                                //   arr.sort(function(a,b){
                                //     return changCode(a) - changCode(b);
                                //   })




                                    //   数组的concat方法，要写参数
                                    //    将arr1 拼接在arr后面，但是原数组不变
                                    // var arr = [1,2,3,4];
                                    // var arr1 = [5,6,7];


                                //    数组的slice方法

                                var arr = [1,2,34];
                                //   从该位开始截取，截取3位，不写就截取到后面的
                                arr.slice(1,3)
                                


    </script>
</body>
</html>